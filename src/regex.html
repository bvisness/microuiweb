<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Regexer</title>

	<style>
		body {
			padding: 0;
			margin: 0;
		}

		canvas {
			position: absolute;
			width: 100%;
			height: 100%;
		}

		#invisible {
			position: absolute;
			opacity: 0;
			pointer-events: none;
		}
	</style>
</head>

<body>
	<canvas></canvas>

	<div id="invisible">
		<div id="copytext"></div>
	</div>

	<script type="text/javascript">
		function dumpMem8(mem) {
			console.log(new Uint8Array(mem.buffer));
		}

		function dumpMem32(mem) {
			console.log(new Uint32Array(mem.buffer));
		}
	</script>
	<script type="module">
		const canvas = document.querySelector('canvas');
		const ctx = canvas.getContext('2d');

		let dpr;
		let textHeight;

		async function init() {
			const mem = new WebAssembly.Memory({
				initial: 100,
			});

			window.mem = mem;

			window.findNonZero = mem => {
				let currentSection = [];
				const buf = new Uint8Array(mem.buffer)

				for (let i = 0; i < buf.length; i++) {
					const v = buf[i];
					if (v) {
						currentSection.push(v);
					} else {
						if (currentSection.length) {
							console.log(i, currentSection);
							currentSection = [];
						}
					}
				}

				if (currentSection.length) {
					console.log(currentSection);
				}
			}

			function getString(ptr, len = null) {
				const codes = [];
				const buf = new Uint8Array(mem.buffer);

				for (let i = 0; len === null || i < len; i++) {
					const char = buf[ptr];
					if (!char) {
						break;
					} else {
						codes.push(char);
						ptr++;
					}
				}

				return String.fromCharCode(...codes);
			}

			function putString(ptr, str) {
				const buf = new Uint8Array(mem.buffer);
				let i = 0;
				for (; i < str.length; i++) {
					buf[ptr + i] = str.charCodeAt(i);
				}
				buf[ptr + i] = 0;
			}

			const sysFetch = fetch("/build/sys.wasm");
			const mainFetch = fetch("/build/regex.wasm");

			const { instance: sys } = await WebAssembly.instantiateStreaming(
				sysFetch,
				{
					env: {
						memory: mem,
					}
				}
			);

			const { instance: test } = await WebAssembly.instantiateStreaming(
				mainFetch,
				{
					env: {
						memory: mem,
						...sys.exports,
						printInt: console.log,
						printLong: console.log,
						printDouble: console.log,
						printString: ptr => console.log(getString(ptr)),
						printError: ptr => console.error(getString(ptr)),
						breakpoint: () => { debugger; },

						canvas_clear: () => {
							ctx.clearRect(0, 0, canvas.width, canvas.height);
						},
						canvas_clip: (x, y, w, h) => {
							ctx.restore();
							ctx.save();
							ctx.beginPath();
							ctx.rect(x * dpr, y * dpr, w * dpr, h * dpr);
							ctx.clip();
						},
						canvas_rect: (x, y, w, h, r, red, green, blue, alpha) => {
							r = Math.min(r, w / 2, h / 2);

							const dx = x * dpr;
							const dy = y * dpr;
							const dr = r * dpr;

							const diw = (w - (2 * r)) * dpr; // device inner width
							const dih = (h - (2 * r)) * dpr; // device inner height

							ctx.beginPath();
							ctx.moveTo(dx + dr, dy);
							ctx.lineTo(dx + dr + diw, dy);
							ctx.arc(dx + dr + diw, dy + dr, dr, -Math.PI/2, 0);
							ctx.lineTo(dx + dr + diw + dr, dy + dr + dih);
							ctx.arc(dx + dr + diw, dy + dr + dih, dr, 0, Math.PI/2);
							ctx.lineTo(dx + dr, dy + dr + dih + dr);
							ctx.arc(dx + dr, dy + dr + dih, dr, Math.PI/2, Math.PI);
							ctx.lineTo(dx, dy + dr);
							ctx.arc(dx + dr, dy + dr, dr, Math.PI, (3*Math.PI)/2);

							ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${alpha/255})`;
							ctx.fill();
						},
						canvas_text: (strPtr, x, y, r, g, b, a) => {
							const str = getString(strPtr);
							ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
							ctx.fillText(str, x * dpr, y * dpr);
						},
						canvas_line: (x1, y1, x2, y2, r, g, b, a, strokeWidth) => {
							ctx.beginPath();
							ctx.moveTo(x1 * dpr, y1 * dpr);
							ctx.lineTo(x2 * dpr, y2 * dpr);

							ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a/255})`;
							ctx.lineWidth = strokeWidth * dpr;
							ctx.stroke();
						},
						canvas_arc: (x, y, radius, angleStart, angleEnd, r, g, b, a, strokeWidth) => {

							ctx.beginPath();
							ctx.arc(x * dpr, y * dpr, radius * dpr, -angleStart, -angleEnd - 0.001, true);
							/*
							The 0.001 is because Firefox has some dumb bug where
							it doesn't draw all the way to the end of the arc and
							leaves some empty pixels. Lines don't join up with arcs
							nicely because of it. It sucks but a little bias seems
							to "fix" it.

							Bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=1664959
							*/

							ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a/255})`;
							ctx.lineWidth = strokeWidth * dpr;
							ctx.stroke();
						},

						measureText: (strPtr, len) => {
							const str = getString(strPtr, len);
							const metrics = ctx.measureText(str);

							return metrics.width / dpr;
						},

						copyText: strPtr => {
							const copytext = document.querySelector('#copytext');
							copytext.innerText = getString(strPtr);
							window.getSelection().selectAllChildren(copytext);
							document.execCommand('copy');
						}
					},
				}
			);

			console.log(test.exports);
			window.regex = test.exports;

			let awake = false;
			function wakeUp() {
				if (awake) {
					return;
				}

				awake = true;
				window.requestAnimationFrame(doFrame);
			}

			canvas.addEventListener('mousemove', e => {
				test.exports.mouseMove(e.clientX, e.clientY);
				wakeUp();
			});
			canvas.addEventListener('mousedown', e => {
				test.exports.mouseDown(e.clientX, e.clientY);
				wakeUp();
			});
			canvas.addEventListener('mouseup', e => {
				test.exports.mouseUp(e.clientX, e.clientY);
				wakeUp();
			});

			function specialKeyEvent(downOrUp, e) {
				e.preventDefault();

				const func = downOrUp === 'down' ? test.exports.keyDown : test.exports.keyUp;

				// MU_KEY_SHIFT        = (1 << 0),
				// MU_KEY_CTRL         = (1 << 1),
				// MU_KEY_ALT          = (1 << 2),
				// MU_KEY_BACKSPACE    = (1 << 3),
				// MU_KEY_RETURN       = (1 << 4),
				// MU_KEY_ARROWLEFT    = (1 << 5),
				// MU_KEY_ARROWRIGHT   = (1 << 6),
				// MU_KEY_ARROWUP      = (1 << 7),
				// MU_KEY_ARROWDOWN    = (1 << 8),
				// MU_KEY_DELETE       = (1 << 9),
				// MU_KEY_HOME         = (1 << 10),
				// MU_KEY_END          = (1 << 11),

				if (e.key === 'Shift') {
					func(1 << 0);
				} else if (e.key === 'Control') {
					func(1 << 1);
				} else if (e.key === 'Alt') {
					func(1 << 2);
				} else if (e.key === 'Backspace') {
					func(1 << 3);
				} else if (e.key === 'Enter') {
					func(1 << 4);
				} else if (e.key === 'ArrowLeft') {
					func(1 << 5);
				} else if (e.key === 'ArrowRight') {
					func(1 << 6);
				} else if (e.key === 'ArrowUp') {
					func(1 << 7);
				} else if (e.key === 'ArrowDown') {
					func(1 << 8);
				} else if (e.key === 'Delete') {
					func(1 << 9);
				} else if (e.key === 'Home') {
					func(1 << 10);
				} else if (e.key === 'End') {
					func(1 << 11);
				}

				wakeUp();
			}
			window.addEventListener('keydown', e => {
				if (e.key.length > 1) {
					specialKeyEvent('down', e);
				} else if (
					!e.ctrlKey
					|| 'a'.indexOf(e.key) > -1
				) {
					putString(test.exports.textInputBuf, e.key);
					test.exports.textInput();
					e.preventDefault();
				}
				wakeUp();
			});
			window.addEventListener('keyup', e => {
				if (e.key.length > 1) {
					specialKeyEvent('up', e);
				}
				wakeUp();
			});

			window.addEventListener('paste', e => {
				putString(
					test.exports.textInputBuf,
					e.clipboardData.getData('text/plain')
				);
				test.exports.textInput();
				wakeUp();
			});
			window.addEventListener('wheel', e => {
				let x = e.deltaX;
				let y = e.deltaY;

				if (e.deltaMode === 1) {
					// "lines"
					x *= 20;
					y *= 20;
				}

				test.exports.scroll(x, y);
				wakeUp();
			});

			function updateCanvasSize() {
				dpr = window.devicePixelRatio;
				canvas.width = window.innerWidth * dpr;
				canvas.height = window.innerHeight * dpr;

				ctx.textBaseline = 'top';
				ctx.font = `${14 * dpr}px -apple-system,BlinkMacSystemFont,segoe ui,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol`;
				textHeight = ctx.measureText('NothinBelowTheBaseline').actualBoundingBoxDescent;
				test.exports.setTextHeight(textHeight / dpr);

				wakeUp();
			}
			updateCanvasSize();
			window.addEventListener('resize', () => { updateCanvasSize(); });

			test.exports.init();

			// TODO: The timer should probably have a cap or otherwise
			// keep ticking in some other way. We have weird issues where
			// the first mouse move after a while fast forwards time
			// by a lot.
			let lastTime = new Date().getTime() / 1000;
			function doFrame() {
				const currentTime = new Date().getTime() / 1000;
				const animating = test.exports.frame(currentTime - lastTime);

				lastTime = currentTime;

				if (animating) {
					window.requestAnimationFrame(doFrame);
				} else {
					awake = false;
				}
			}
			wakeUp();
		}
		init();
	</script>
</body>

</html>
