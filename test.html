<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>WASM Test</title>

	<style>
		body {
			padding: 0;
			margin: 0;
		}

		canvas {
			position: absolute;
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>
	<canvas></canvas>
	<script type="text/javascript">
		function dumpMem8(mem) {
			console.log(new Uint8Array(mem.buffer));
		}

		function dumpMem32(mem) {
			console.log(new Uint32Array(mem.buffer));
		}
	</script>
	<script type="module">
		const canvas = document.querySelector('canvas');
		const ctx = canvas.getContext('2d');

		let dpr;
		let textHeight;

		async function init() {
			const mem = new WebAssembly.Memory({
				initial: 10,
			});

			window.mem = mem;

			function findNonZero(mem) {
				let currentSection = [];
				const buf = new Uint8Array(mem.buffer)

				for (let i = 0; i < buf.length; i++) {
					const v = buf[i];
					if (v) {
						currentSection.push(v);
					} else {
						if (currentSection.length) {
							console.log(i, currentSection);
							currentSection = [];
						}
					}
				}

				if (currentSection.length) {
					console.log(currentSection);
				}
			}

			function getString(ptr, len = null) {
				const codes = [];
				const buf = new Uint8Array(mem.buffer);

				for (let i = 0; len === null || i < len; i++) {
					const char = buf[ptr];
					if (!char) {
						break;
					} else {
						codes.push(char);
						ptr++;
					}
				}

				return String.fromCharCode(...codes);
			}

			function putString(ptr, str) {
				const buf = new Uint8Array(mem.buffer);
				let i = 0;
				for (; i < str.length; i++) {
					buf[ptr + i] = str.charCodeAt(i);
				}
				buf[ptr + i] = 0;
			}

			const sysFetch = fetch("/sys.wasm");
			const mainFetch = fetch("/test.wasm");

			const { instance: sys } = await WebAssembly.instantiateStreaming(
				sysFetch,
				{
					env: {
						memory: mem,
					}
				}
			);

			const { instance: test } = await WebAssembly.instantiateStreaming(
				mainFetch,
				{
					env: {
						memory: mem,
						...sys.exports,
						printInt: console.log,
						printLong: console.log,
						printDouble: console.log,
						printString: ptr => console.log(getString(ptr)),
						printError: ptr => console.error(getString(ptr)),
						breakpoint: () => { debugger; },

						canvas_clear: () => {
							ctx.clearRect(0, 0, canvas.width, canvas.height);
						},
						canvas_clip: (x, y, w, h) => {
							ctx.restore();
							ctx.save();
							ctx.beginPath();
							ctx.rect(x * dpr, y * dpr, w * dpr, h * dpr);
							ctx.clip();
						},
						canvas_rect: (x, y, w, h, r, g, b, a) => {
							ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
							ctx.fillRect(x * dpr, y * dpr, w * dpr, h * dpr);
						},
						canvas_circle: (x, y, radius, r, g, b, a) => {
							ctx.beginPath();
							ctx.arc(x * dpr, y * dpr, radius * dpr, 0, 2 * Math.PI);
							ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
							ctx.fill();
						},
						canvas_text: (strPtr, x, y, r, g, b, a) => {
							const str = getString(strPtr);
							ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
							ctx.fillText(str, x * dpr, y * dpr);
						},

						measureText: (strPtr, len) => {
							const str = getString(strPtr, len);
							const metrics = ctx.measureText(str);

							return metrics.width / dpr;
						},
					},
				}
			);

			console.log(test.exports);

			canvas.addEventListener('mousemove', e => {
				test.exports.mouseMove(e.clientX, e.clientY);
				window.requestAnimationFrame(doFrame);
			});
			canvas.addEventListener('mousedown', e => {
				test.exports.mouseDown(e.clientX, e.clientY);
				window.requestAnimationFrame(doFrame);
			});
			canvas.addEventListener('mouseup', e => {
				test.exports.mouseUp(e.clientX, e.clientY);
				window.requestAnimationFrame(doFrame);
			});

			function specialKeyEvent(downOrUp, e) {
				e.preventDefault();

				const func = downOrUp === 'down' ? test.exports.keyDown : test.exports.keyUp;

				// MU_KEY_SHIFT        = (1 << 0),
				// MU_KEY_CTRL         = (1 << 1),
				// MU_KEY_ALT          = (1 << 2),
				// MU_KEY_BACKSPACE    = (1 << 3),
				// MU_KEY_RETURN       = (1 << 4)

				if (e.key === 'Shift') {
					func(1 << 0);
				} else if (e.key === 'Control') {
					func(1 << 1);
				} else if (e.key === 'Alt') {
					func(1 << 2);
				} else if (e.key === 'Backspace') {
					func(1 << 3);
				} else if (e.key === 'Enter') {
					func(1 << 4);
				}
			}
			window.addEventListener('keydown', e => {
				if (e.key.length > 1) {
					specialKeyEvent('down', e);
				} else {
					putString(test.exports.textInputBuf, e.key);
					test.exports.textInput();
				}
				window.requestAnimationFrame(doFrame);
			});
			window.addEventListener('keyup', e => {
				if (e.key.length > 1) {
					specialKeyEvent('up', e);
				}
				window.requestAnimationFrame(doFrame);
			});

			window.addEventListener('paste', e => {
				putString(
					test.exports.textInputBuf,
					e.clipboardData.getData('text/plain')
				);
				test.exports.textInput();
				window.requestAnimationFrame(doFrame);
			});
			window.addEventListener('wheel', e => {
				let x = e.deltaX;
				let y = e.deltaY;

				if (e.deltaMode === 1) {
					// "lines"
					x *= 20;
					y *= 20;
				}

				test.exports.scroll(x, y);
				window.requestAnimationFrame(doFrame);
			});

			function updateCanvasSize() {
				dpr = window.devicePixelRatio;
				canvas.width = window.innerWidth * dpr;
				canvas.height = window.innerHeight * dpr;

				ctx.textBaseline = 'top';
				ctx.font = `${14 * dpr}px -apple-system,BlinkMacSystemFont,segoe ui,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol`;
				textHeight = ctx.measureText('NothinBelowTheBaseline').actualBoundingBoxDescent;
				test.exports.setTextHeight(textHeight / dpr);

				window.requestAnimationFrame(doFrame);
			}
			updateCanvasSize();
			window.addEventListener('resize', () => { updateCanvasSize(); });

			test.exports.init();

			// TODO: The timer should probably have a cap or otherwise
			// keep ticking in some other way. We have weird issues where
			// the first mouse move after a while fast forwards time
			// by a lot.
			let lastTime = new Date().getTime() / 1000;
			function doFrame() {
				const currentTime = new Date().getTime() / 1000;
				const animating = test.exports.frame(currentTime - lastTime);

				lastTime = currentTime;

				if (animating) {
					window.requestAnimationFrame(doFrame);
				}
			}
			window.requestAnimationFrame(doFrame);
		}
		init();
	</script>
</body>

</html>
